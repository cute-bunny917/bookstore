# Django settings for config project.
# Generated by 'django-admin startproject' using Django 3.1.13.
"""
django-environ is the Python package that allows you to use Twelve-factor methodology
to configure your Django application with environment variables.

install environ package in running docker container 
We will also need to spin down our Docker container and rebuild it with the new package.

$ docker-compose exec web pipenv install 'environs[django]==8.0.0'
$ docker-compose down
$ docker-compose up -d --build
"""
import socket
from environs import Env
from pathlib import Path


env = Env()
env.read_env()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve(strict=True).parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/dev/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
"""
The SECRET_KEY is a 50-character random
string generated anew each time the startproject command is run. To
generate a new key we can use Python’s built-in secrets module.

$ python -c 'import secrets; print(secrets.token_urlsafe(38))'

The parameter token_urlsafe returns the number of bytes in a URL-safe
text string. With Base64 encoding on average each byte has 1.3 characters.
So using 38 results in 51 characters in this case. The important thing is that
your SECRET_KEY has at least 50 characters. Each time you run the
command, a new value is outputted.
"""
SECRET_KEY = env("DJANGO_SECRET_KEY")

# SECURITY WARNING: don't run with debug turned on in production!

"""
This means default to a production value of False if no environment
variable is present. If one is called DJANGO_DEBUG then use that. We would
keep the DJANGO_DEBUG variable in the local docker-compose.yml file, but
remove it in docker-compose-prod.yml. This approach results in a smaller
docker-compose-prod.yml file and it is arguably more secure since if for
some reason environment variables are not loading in properly, we won’t
turn on local development settings by accident. Only production values are
used.
"""
DEBUG = env.bool("DJANGO_DEBUG", default=False)

"""
As the Django deployment checklist notes, there are a number of settings
that must be updated before a website can be deployed safely in production.
Chief among them are DEBUG and ALLOWED_HOSTS.

ALLOWED_HOSTS, which controls the specific hosts or domains 
that can access the website. We will add the two local ports
localhost and 127.0.0.1 as well as .herokuapp.com,
which will be used by Heroku for our production website.
"""
ALLOWED_HOSTS = ['.herokuapp.com', 'localhost', '127.0.0.1']

"""
Django relies on the staticfiles app to manage static files from across our
entire project, make them accessible for rapid local development on the file
system, and also combine them into a single location that can be served in a
better performing manner in production. 

(static files)
whitenoise package:
For local development Django relies on the staticfiles app to automatically
gather and serve static files from across the entire project. This is
convenient, but quite inefficient and likely insecure, too.
For production the collectstatic must be run to compile all static files into a
single directory specified by STATIC_ROOT. They can then be served
either on the same server, a separate server, or a dedicated cloud
service/CDN by updating STATICFILES_STORAGE.
In our project, we will rely on serving files from our server with the aid of
the WhiteNoise project which works extremely well on Heroku and is both
faster and more configurable than Django defaults.
The first step is to install whitenoise within Docker and stop the running
containers.

$ docker-compose exec web pipenv install whitenoise==5.1.0
$ docker-compose down

configuration:
we can add --nostatic flag to the runserver command, this becomes
tiring in practice. A better approach is to add
whitenoise.runserver_nostatic before django.contrib.staticfiles in
the INSTALLED_APPS config which will do the same thing. We’ll also add it
to our MIDDLEWARE right below SecurityMiddleware and update
STATICFILES_STORAGE to use WhiteNoise now.
"""

"""
(User Registration)
user registration is a complex area with many moving parts 
and one area where we really do not want to make a security mistake.

django-allauth package:
Integrated set of Django applications addressing 
authentication, registration, account management 
as well as 3rd party (social) account authentication.

$ docker-compose exec web pipenv install django-allauth==0.42.0
$ docker-compose down
$ docker-compose up -d --build

configuration:
1) Add 'allauth' and 'allauth.account' apps to INSTALLED_APPS.
2) Add extra configuration at end of file.
3) Add allauth to urls.py.
4) allauth  app looks for templates within a templates/account directory instead templates/registration.

$ mkdir -p templates/account
$ touch templates/account/login.html
$ touch templates/account/signup.html

5) The last step is to update the URL links within templates/_base.html and
templates/home.html ....based on allauth documentations
https://django-allauth.readthedocs.io/en/latest/views.html
https://github.com/pennersr/django-allauth/blob/master/allauth/account/urls.py

href="{% url 'account_logout' %}
href="{% url 'account_login' %}
href="{% url 'account_signup' %}

Django comes with an optional “sites” framework. 
It is a hook for associating objects and functionality to particular websites, 
and it is a holding place for the domain names and “verbose” names of your Django-powered sites.
Use it if your single Django installation powers more than one site and 
you need to differentiate between those sites in some way.

add 'django.contrib.sites', to installed apps.
then add SITE_ID = 1 at end of file , that represent number of sites supported by single django project.

"""

"""
django-crispy package:

django-crispy-forms provides you with a |crispy filter and {% crispy %} tag 
that will let you control the rendering behavior of your Django forms in a very elegant and DRY way.
Have full control without writing custom form templates. All this without breaking the standard way
of doing things in Django, so it plays nice with any other form application.

installation:
$ docker-compose exec web pipenv install django-crispy-forms==1.9.2
$ docker-compose down
$ docker-compose up -d --build

configuration:
1) Add 'crispy_forms' to INSTALLED_APPS.
2) Add configuration at end of file.
3) load crispy in html files {% load crispy_forms_tags %}.
4) Add crispy filter and tag to html files.
5) We will take this time to also add Bootstrap styling to html files.
"""

"""
Before we can optimize our database queries we need to see them. And for
this the default tool in the Django community is the third-party package
django-debug-toolbar. It comes with a configurable set of panels to inspect
the complete request/response cycle of any given page.

$ docker-compose exec web pipenv install django-debug-toolbar==2.2
$ docker-compose down

There are three separate configurations to set in our config/settings.py
file:
1. Add 'debug_toolbar' to INSTALLED_APPS
2. Middleware
3. INTERNAL_IPS

$ docker-compose up -d --build

4. update our URLconf

"""
# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    # whitenoise configuration part1 - before django.contrib.staticfiles
    'whitenoise.runserver_nostatic',
    'django.contrib.staticfiles',

    'django.contrib.sites',  # django site framework configuration

    # Third-party
    'crispy_forms',
    'allauth',
    'allauth.account',
    'debug_toolbar',  # debug_toolbar config part1

    # Local
    'accounts',
    'pages',
    'books',
]

MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware',  # per-site cache config part1
    # whitenoise configuration part2 - after SecurityMiddleware
    'django.middleware.security.SecurityMiddleware',
    'whitenoise.middleware.WhiteNoiseMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'debug_toolbar.middleware.DebugToolbarMiddleware',  # debug_toolbar config part2
    'django.middleware.cache.FetchFromCacheMiddleware',  # per-site cache config part2
]

ROOT_URLCONF = 'config.urls'
"""
We'll also update TEMPLATES so
that Django will look for a project-level templates folder. By default
Django looks within each app for a templates folder, but organizing all
templates in one space is easier to manage.
'DIRS': [str(BASE_DIR.joinpath('templates'))],

Note that updating the DIRS setting means that Django will also look in this new folder;
it will still look for any templates folders within an app.
"""
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [str(BASE_DIR.joinpath('templates'))],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'


# Database
# https://docs.djangoproject.com/en/dev/ref/settings/#databases

# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.postgresql',
#         'NAME': 'postgres',
#         'USER': 'postgres',
#         'PASSWORD': 'postgres',
#         'HOST': 'db',
#         'PORT': 5432
#     }
# }

"""
switch over to PostgreSQL for our project which takes
three steps:
1) install a database adapter, psycopg2, so Python can talk to PostgreSQL
$ docker-compose exec web pipenv install psycopg2-binary==2.8.5
2) update the DATABASE config in settings.py file
3) install and run PostgreSQL locally (we will use dockerized postgres)
"""
DATABASES = {  # postgres config part2
    "default": env.dj_db_url("DATABASE_URL", default="postgres://postgres@db/postgres")
}

# Password validation
# https://docs.djangoproject.com/en/dev/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/dev/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


""" Static files Settings(CSS, JavaScript, Images)
When it comes time to deploy a Django project, the collectstatic command will automatically compile all
available static files throughout the entire project into a single directory.
$ docker-compose exec web python manage.py collectstatic
https://docs.djangoproject.com/en/dev/howto/static-files/
"""
# This sets the URL that we can use to reference static files.
STATIC_URL = '/static/'
# which defines the location of static files in local development.
STATICFILES_DIRS = [str(BASE_DIR.joinpath('static'))]
# is the location of static files for production so it must be set to a different name, typically staticfiles.
STATIC_ROOT = str(BASE_DIR.joinpath('staticfiles'))
"""
which tells Django how to look for static file directories. It is implicitly set for us and although this is
an optional step, I prefer to make it explicit in all projects.
The FileSystemFinder looks within the STATICFILES_DIRS setting, which
we set to static, for any static files. Then the AppDirectoriesFinder
looks for any directories named static located within an app
"""
STATICFILES_FINDERS = [
    "django.contrib.staticfiles.finders.FileSystemFinder",
    "django.contrib.staticfiles.finders.AppDirectoriesFinder",
]
# custom user model config
AUTH_USER_MODEL = 'accounts.CustomUser'

# django-crispy-forms
CRISPY_TEMPLATE_PACK = 'bootstrap4'

# django-allauth config
LOGIN_REDIRECT_URL = 'home'
ACCOUNT_LOGOUT_REDIRECT = 'home'
# ACCOUNT_LOGOUT_REDIRECT actually overrides the built-in LOGOUT_REDIRECT_URL
# Defaults to Django’s LOGOUT_REDIRECT_URL, unless that is empty, then “/” is used.
SITE_ID = 1  # optional django site framework configuration that represent number of supported sites by django project

AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend',
    # explicit the implicit django settings ,
    # which is used when Django attempts to authenticate a user.
    'allauth.account.auth_backends.AuthenticationBackend',
    # allauth configuration: which will allow us to switch over to using login via e-mail.

)
"""
since we don’t yet have a SMTP server properly configured, it will result in an error.
The solution, for now, is to have Django output any emails to the command line console instead. 
we need to  change the console to smtp , then add extra smtp configurations if we plan to use smtp server 
to handle registration emails.
"""
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

# allauth option, remember me box configuration True: always remember false: to not remember
ACCOUNT_SESSION_REMEMBER = True
# allauth option to ask password twice for registration
ACCOUNT_SIGNUP_PASSWORD_ENTER_TWICE = False
ACCOUNT_USERNAME_REQUIRED = False  # allauth option, login by username
# allauth option , login by email(populate username for us based on email address in django admin)
ACCOUNT_AUTHENTICATION_METHOD = 'email'
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_UNIQUE_EMAIL = True

# Default email address to use for various automated correspondence from the site manager(s). 
# for example , password reset request
DEFAULT_FROM_EMAIL = 'admin@djangobookstore.com'
"""
File/Image Uploads
for image we need to install Python Imaging Library(pillow)
$ docker-compose exec web pipenv install pillow==7.2.0
$ docker-compose down
$ docker-compose up -d --build

anything uploaded by a user, whether it be a file or an image, is referred to as media.
There are always security concerns when dealing with user-uploaded content.
Notably, it's important to validate all uploaded files to ensure they are what
they say they are. There are a number of nasty ways a malicious actor can 
attack a website that blindly accepts user uploads.

To start let's add two new configurations to the config/settings.py file.
By default MEDIA_URL and MEDIA_ROOT are both empty and not displayed so
we need to configure them:
We can add both of these settings after STATICFILES_FINDERS near the
bottom of the config/settings.py file

$ mkdir media
$ mkdir media/covers

step 1) update url.py
we need to import both settings and static at the top and then adding an additional line at the bottom.
+ static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

step 2) update model.py as ImageField
cover = models.ImageField(upload_to='covers/')

step 3) check admin for new ImageField
step 4) update template books_detail.html to support image upload.
<img class="bookcover" src="{{ book.cover.url}}" alt="{{ book.title }}">
 
step 5) We must add some basic logic to our template so that if a cover is not
present the template doesn’t look for it! This can be done using an if
statement that checks for book.cover and displays it if it exists.

Summary (url,model,template) + basic logic

for production , its better to use CDN to store user uploaded files.
"""
# MEDIA_URL is the URL we can use in our templates for the files
MEDIA_URL = '/media/'
# MEDIA_ROOT is the absolute file system path to the directory for user-uploaded files.
MEDIA_ROOT = str(BASE_DIR.joinpath('media'))

# django-debug-toolbar  config part3 - it ensures that our INTERNAL_IPS matches that of our Docker host.
hostname, _, ips = socket.gethostbyname_ex(socket.gethostname())
INTERNAL_IPS = [ip[:-1] + "1" for ip in ips]

# per-site cache config part3
CACHE_MIDDLEWARE_ALIAS = 'default'
CACHE_MIDDLEWARE_SECONDS = 604800
CACHE_MIDDLEWARE_KEY_PREFIX = ''
# 4 Deployment Checklist issues resolved , SSL,HSTS,COOKIE,PROXY_SSL_HEADER before deplyment to heroku
# https://docs.djangoproject.com/en/3.1/howto/deployment/checklist/
SECURE_SSL_REDIRECT = env.bool("DJANGO_SECURE_SSL_REDIRECT", default=True)
SECURE_HSTS_SECONDS = env.int("DJANGO_SECURE_HSTS_SECONDS", default=2592000)
SECURE_HSTS_INCLUDE_SUBDOMAINS = env.bool(
    "DJANGO_SECURE_HSTS_INCLUDE_SUBDOMAINS", default=True)
SECURE_HSTS_PRELOAD = env.bool("DJANGO_SECURE_HSTS_PRELOAD", default=True)
SESSION_COOKIE_SECURE = env.bool("DJANGO_SESSION_COOKIE_SECURE", default=True)
CSRF_COOKIE_SECURE = env.bool("DJANGO_CSRF_COOKIE_SECURE", default=True)
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

# whitenoise configuration part3 - storage
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'


"""
Caching
Consider that our Bookstore project is a dynamic website. Each time a user
requests a page our server has to make various calculations including
database queries, template rendering, and so on before servicing it. This
takes time and is much slower than simply reading a file from a static site
where the content does not change.
On large sites, though, this type of overhead can be quite slow and caching
is one of the first solutions in a web developer's tool bag. Implementing
caching on our current project is definitely overkill, but we will nonetheless
review the options and implement a basic version.
A cache is an in-memory storing of an expensive calculation. Once
executed it doesn't need to be run again! The two most popular options are
Memcached which features native Django support and Redis which is
commonly implemented with the django-redis third-party package.
Django has its own cache framework which includes four different caching
options in descending order of granularity:
1) The per-site cache is the simplest to set up and caches your entire site.
2) The per-view cache lets you cache individual views.
3) Template fragment caching lets you specify a specific section of a
template to cache.4) The low-level cache API lets you manually set, retrieve, and maintain
specific objects in the cache.
Why not just cache everything all the time? One reason is that cache
memory is expensive, as it's stored as RAM: think about the cost of going
from 8GB to 16GB of RAM on your laptop vs. 256GB to 512GB of hard
drive space. Another is the cache must be “warm,” that is filled with
updated content, so depending upon the needs of a site, optimizing the
cache so it is accurate, but not wasteful, takes quite a bit of tuning.
If you wanted to implement per-site caching, which is the simplest
approach, you'd add UpdateCacheMiddleware at the very top of the
MIDDLEWARE configuration in config/settings.py and
FetchFromCacheMiddleware at the very bottom. Also set three additional
fields CACHE_MIDDLEWARE_ALIAS,
CACHE_MIDDLEWARE_SECONDS, and
CACHE_MIDDLEWARE_KEY_PREFIX.
"""
